; This is the Calva REPL Window.
; It's just a file, really, with some special treatment from Calva.
; Use it as a REPL input prompt if you like. (When the REPL is connected.)
; TIPS: The keyboard shortcut `ctrl+alt+o r` shows and focuses this window
; Please see https://calva.io/repl-window/ for more info.
; Happy coding! ♥️

; TIPS: As with any Clojure file when the REPL is connected:
; - `alt+enter` evaluates the current top level form.
; - `ctrl+enter` evaluates the current form.
; Special for this file:
; - `alt+up` and `alt+down` traverse up and down the REPL command history
;    when the cursor is after the last contents at the prompt
; 
; See also the Calva Inspector: https://calva.io/inspector/

PLEASE NOTE
We will update the default location of this file.
The new default location will be
  "<projectRootPath>/.calva/repl.calva-repl"
For now the legacy path is used by default.
To give yourself a smooth transition, you can opt in
to the change, by configuring this setting as false:
  "calva.useLegacyReplWindowPath"
and then add "**/.calva/repl.calva-repl" to your ".gitignore" file.


This file is configured as the output destination for all REPL output.
You can configure this with the setting:
  "calva.outputDestinations"


; Jacking in...
; Connecting using "Leiningen" project type.
; You can make Calva auto-select this.
;   - See https://calva.io/connect-sequences/
; 

; Starting Jack-in: (cd /home/alexisc183/Documents/Clojure/weeklyvents; lein update-in :dependencies conj '[nrepl,"1.3.1"]' -- update-in :plugins conj '[cider/cider-nrepl,"0.52.1"]' -- update-in '[:repl-options,:nrepl-middleware]' conj '["cider.nrepl/cider-middleware"]' -- with-profile +uberjar repl :headless)
; Using host:port 127.0.0.1:43149 ...
; Hooking up nREPL sessions ...
; Connected session: clj
; Evaluating code from settings: 'calva.autoEvaluateCode.onConnect.clj'
nil
clj꞉weeklyvents.core꞉> 
"Please see https://calva.io/output/#about-stdout-in-the-repl-window
about why stdout printed to this file is prepended with `;` to be line comments."
clj꞉weeklyvents.core꞉> 
; Jack-in done.
clj꞉weeklyvents.core꞉> 
#'weeklyvents.structs/event
clj꞉weeklyvents.structs꞉> 
nil
clj꞉weeklyvents.structs꞉> 
(ns weeklyvents.structs [:require [clojure.test :refer [:all]]])
; Syntax error macroexpanding clojure.core/ns at (output.calva-repl:55:1).
; ([:require [clojure.test :refer [:all]]]) - failed: Extra input spec: :clojure.core.specs.alpha/ns-form
clj꞉weeklyvents.structs꞉> (ns weeklyvents.structs (:require [clojure.test :refer [:all]]))
; Syntax error macroexpanding clojure.core/ns at (output.calva-repl:58:27).
; ((:require [clojure.test :refer [:all]])) - failed: Extra input spec: :clojure.core.specs.alpha/ns-form
clj꞉weeklyvents.structs꞉> 
(ns weeklyvents.structs (:require [clojure.test :refer :all]))
nil
clj꞉weeklyvents.structs꞉> 
(type event)
clojure.lang.PersistentStructMap$Def
clj꞉weeklyvents.structs꞉>
; Syntax error (ClassNotFoundException) compiling at (output.calva-repl:0:0).
; clj꞉weeklyvents.structs꞉>
; Syntax error (ClassNotFoundException) compiling at (output.calva-repl:0:0).
; clj꞉weeklyvents.structs꞉>
; Syntax error (ClassNotFoundException) compiling at (output.calva-repl:0:0).
; clj꞉weeklyvents.structs꞉>
; Syntax error (ClassNotFoundException) compiling at (output.calva-repl:0:0).
; clj꞉weeklyvents.structs꞉>
; nREPL Connection was closed
; Jacking in...
; Connecting using "Leiningen" project type.
; You can make Calva auto-select this.
;   - See https://calva.io/connect-sequences/
; 

; Starting Jack-in: (cd /home/alexisc183/Documents/Clojure/weeklyvents; lein update-in :dependencies conj '[nrepl,"1.3.1"]' -- update-in :plugins conj '[cider/cider-nrepl,"0.52.1"]' -- update-in '[:repl-options,:nrepl-middleware]' conj '["cider.nrepl/cider-middleware"]' -- with-profile +uberjar repl :headless)
; Using host:port 127.0.0.1:34725 ...
; Hooking up nREPL sessions ...
; Connected session: clj
; Evaluating code from settings: 'calva.autoEvaluateCode.onConnect.clj'
nil
clj꞉weeklyvents.core꞉> 
; Jack-in done.
clj꞉weeklyvents.core꞉> 
#'weeklyvents.structs/parse-event
clj꞉weeklyvents.structs꞉> 
#'weeklyvents.structs/parse-event
clj꞉weeklyvents.structs꞉> 
(is)
; Syntax error compiling at (output.calva-repl:96:1).
; Unable to resolve symbol: is in this context
clj꞉weeklyvents.structs꞉> 
(ns weeklyvents.structs (:require [clojure.test :refer :all]))
nil
clj꞉weeklyvents.structs꞉> 
(is)
; Execution error (ArityException) at nrepl.middleware.interruptible-eval/evaluator$run$fn (interruptible_eval.clj:106).
; Wrong number of args (0) passed to: clojure.test/is
clj꞉weeklyvents.structs꞉> 
(def x 4)
#'weeklyvents.structs/x
clj꞉weeklyvents.structs꞉> 
(def x 6)
#'weeklyvents.structs/x
clj꞉weeklyvents.structs꞉> 
(defstruct person :name :age)
#'weeklyvents.structs/person
clj꞉weeklyvents.structs꞉> 
(def my-person (struct "John" 18))
; Syntax error (ClassCastException) compiling at (REPL:116:16).
; class java.lang.String cannot be cast to class clojure.lang.PersistentStructMap$Def (java.lang.String is in module java.base of loader 'bootstrap'; clojure.lang.PersistentStructMap$Def is in unnamed module of loader 'app')
clj꞉weeklyvents.structs꞉> 
(def my-person (struct person "John" 18))
#'weeklyvents.structs/my-person
clj꞉weeklyvents.structs꞉> 
(let [{n :name a :age} my-person])
nil
clj꞉weeklyvents.structs꞉> 
(let [{n :nombre a :edad} my-person])
nil
clj꞉weeklyvents.structs꞉> 
(let [{n :name a: age} my-person] (str n " : " a))
; Syntax error reading source at (REPL:129:18).
; Invalid token: a:
clj꞉weeklyvents.structs꞉> 
(let [{n :name a :age} my-person] (str n " : " a))
"John : 18"
clj꞉weeklyvents.structs꞉> 
(let [{n :nombre a :edad} my-person] (str n " : " a))
" : "
clj꞉weeklyvents.structs꞉> 
(type my-person)
clojure.lang.PersistentStructMap
clj꞉weeklyvents.structs꞉> 
clojure.lang.PersistentStructMap
clj꞉weeklyvents.structs꞉> 
; Prueba 1: Comprobar si la función `parse-event` realmente devuelve un struct map cuando se le proporciona una cadena con el formato correcto
(defn foo\
  [x]\
  x)
; Syntax error macroexpanding clojure.core/defn at (output.calva-repl:145:1).
; \newline - failed: vector? at: [:fn-tail :arity-1 :params] spec: :clojure.core.specs.alpha/param-list
; \newline - failed: (or (nil? %) (sequential? %)) at: [:fn-tail :arity-n :bodies] spec: :clojure.core.specs.alpha/params+body
clj꞉weeklyvents.structs꞉> 
(defn foo
  [x]
  x)
#'weeklyvents.structs/foo
clj꞉weeklyvents.structs꞉> 
; Prueba 1: Comprobar si la función `parse-event` realmente devuelve un struct map cuando se le proporciona una cadena con el formato correcto
()"Hola\nHola"
clj꞉weeklyvents.structs꞉> 
; Hola
; Hola
nil
clj꞉weeklyvents.structs꞉> 
; HolaHola
nil
clj꞉weeklyvents.structs꞉> 
; Prueba 1: Comprobar si la función `parse-event` realmente devuelve un struct map cuando se le proporciona una cadena con el formato correcto
(def separador \u001f)
#'weeklyvents.structs/separador
clj꞉weeklyvents.structs꞉> 
(is (=
     (type (parse-event (str "09:00:00" separador "Desayuno" separador "Lunes")))
     clojure.lang.PersistentStructMap))
; 
; ERROR in () (Enum.java:293)
; expected: (= (type (parse-event (str "09:00:00" separador "Desayuno" separador "Lunes"))) clojure.lang.PersistentStructMap)
;   actual: java.lang.IllegalArgumentException: No enum constant java.time.DayOfWeek.Lunes
;  at java.lang.Enum.valueOf (Enum.java:293)
;     java.time.DayOfWeek.valueOf (DayOfWeek.java:109)
;     weeklyvents.structs$parse_event.invokeStatic (NO_SOURCE_FILE:27)
;     weeklyvents.structs$parse_event.invoke (NO_SOURCE_FILE:20)
;     weeklyvents.structs$eval11540.invokeStatic (NO_SOURCE_FILE:172)
;     weeklyvents.structs$eval11540.invoke (NO_SOURCE_FILE:171)
;     clojure.lang.Compiler.eval (Compiler.java:7176)
;     nrepl.middleware.interruptible_eval$evaluator$run__1443$fn__1454.invoke (interruptible_eval.clj:106)
;     nrepl.middleware.interruptible_eval$evaluator$run__1443.invoke (interruptible_eval.clj:101)
;     nrepl.middleware.session$session_exec$session_loop__1526.invoke (session.clj:230)
;     nrepl.SessionThread.run (SessionThread.java:21)
nil
clj꞉weeklyvents.structs꞉> 
; Prueba 1: Comprobar si la función `parse-event` realmente devuelve un struct map cuando se le proporciona una cadena con el formato correcto
(def separador \u001f)
#'weeklyvents.structs/separador
clj꞉weeklyvents.structs꞉> 
(is (=
     (type (parse-event (str "09:00:00" separador "Desayuno" separador "MONDAY")))
     clojure.lang.PersistentStructMap))
true
clj꞉weeklyvents.structs꞉> 
(is (instance? clojure.lang.PersistentStructMap (struct event 6 7 8)))
true
clj꞉weeklyvents.structs꞉> 
(is (instance? event (struct event 6 7 8)))
; 
; ERROR in () (core.clj:144)
; expected: (instance? event (struct event 6 7 8))
;   actual: java.lang.ClassCastException: class clojure.lang.PersistentStructMap$Def cannot be cast to class java.lang.Class (clojure.lang.PersistentStructMap$Def is in unnamed module of loader 'app'; java.lang.Class is in module java.base of loader 'bootstrap')
;  at clojure.core$instance_QMARK___5389.invokeStatic (core.clj:144)
;     clojure.core/instance_QMARK_ (core.clj:144)
;     weeklyvents.structs$eval11553.invokeStatic (NO_SOURCE_FILE:203)
;     weeklyvents.structs$eval11553.invoke (NO_SOURCE_FILE:203)
;     clojure.lang.Compiler.eval (Compiler.java:7176)
;     nrepl.middleware.interruptible_eval$evaluator$run__1443$fn__1454.invoke (interruptible_eval.clj:106)
;     nrepl.middleware.interruptible_eval$evaluator$run__1443.invoke (interruptible_eval.clj:101)
;     nrepl.middleware.session$session_exec$session_loop__1526.invoke (session.clj:230)
;     nrepl.SessionThread.run (SessionThread.java:21)
nil
clj꞉weeklyvents.structs꞉> 
(instance? event (struct event 6 7 8))
; Execution error (ClassCastException) at weeklyvents.structs/eval11558 (REPL:219).
; class clojure.lang.PersistentStructMap$Def cannot be cast to class java.lang.Class (clojure.lang.PersistentStructMap$Def is in unnamed module of loader 'app'; java.lang.Class is in module java.base of loader 'bootstrap')
clj꞉weeklyvents.structs꞉> 
(type event)
clojure.lang.PersistentStructMap$Def
clj꞉weeklyvents.structs꞉> 
(instance? event (struct event 6 7 8))
; Execution error (ClassCastException) at weeklyvents.structs/eval11562 (REPL:226).
; class clojure.lang.PersistentStructMap$Def cannot be cast to class java.lang.Class (clojure.lang.PersistentStructMap$Def is in unnamed module of loader 'app'; java.lang.Class is in module java.base of loader 'bootstrap')
clj꞉weeklyvents.structs꞉> 
; Prueba 1: Comprobar si la función `parse-event` realmente devuelve un struct map cuando se le proporciona una cadena con el formato correcto
(def separador \u001f)
#'weeklyvents.structs/separador
clj꞉weeklyvents.structs꞉> 
(is (instance? clojure.lang.PersistentStructMap (parse-event (str "09:00:00" separador "Desayuno" separador "MONDAY"))))
true
clj꞉weeklyvents.structs꞉> 
(:name (parse-event (str "09:00:00" separador "Desayuno" separador "MONDAY")))
"Desayuno"
clj꞉weeklyvents.structs꞉> 
(:nombre (parse-event (str "09:00:00" separador "Desayuno" separador "MONDAY")))
nil
clj꞉weeklyvents.structs꞉> 
; Prueba 2: Comprobar si se puede recuperar el nombre del evento con la palabra clave `:nombre`
(def evento (struct event (LocalTime/now) "Lonche" DayOfWeek/MONDAY))
#'weeklyvents.structs/evento
clj꞉weeklyvents.structs꞉> 
:nombre evento
{:initial-time #object[java.time.LocalTime 0xec0fe36 "13:29:36.665453567"],
 :name "Lonche",
 :initial-day-of-week #object[java.time.DayOfWeek 0x28601add "MONDAY"]}
clj꞉weeklyvents.structs꞉> 
:nombre evento
{:initial-time #object[java.time.LocalTime 0xec0fe36 "13:29:36.665453567"],
 :name "Lonche",
 :initial-day-of-week #object[java.time.DayOfWeek 0x28601add "MONDAY"]}
clj꞉weeklyvents.structs꞉> 
(:nombre evento)
nil
clj꞉weeklyvents.structs꞉> 
(-> evento
    (:nombre))
nil
clj꞉weeklyvents.structs꞉> 
; Prueba 2: Comprobar si se puede recuperar el nombre del evento con la palabra clave `:nombre`
(def evento (struct event (LocalTime/now) "Lonche" DayOfWeek/MONDAY))
#'weeklyvents.structs/evento
clj꞉weeklyvents.structs꞉> 
(is (-> evento
        (:nombre)
        (nil?)
        (not)))
; 
; FAIL in () (NO_SOURCE_FILE:268)
; expected: (-> evento (:nombre) (nil?) (not))
;   actual: false
false
clj꞉weeklyvents.structs꞉> 
; Prueba 2: Comprobar si se puede recuperar el nombre del evento con la palabra clave `:nombre`
(def evento (struct event (LocalTime/now) "Lonche" DayOfWeek/MONDAY))
#'weeklyvents.structs/evento
clj꞉weeklyvents.structs꞉> 
(is (= "Lonche" (:nombre evento)))
; 
; FAIL in () (NO_SOURCE_FILE:282)
; expected: (= "Lonche" (:nombre evento))
;   actual: (not (= "Lonche" nil))
false
clj꞉weeklyvents.structs꞉> 
(throw (FormatException.))
; Execution error (FormatException) at weeklyvents.structs/eval11584 (REPL:289).
; null
clj꞉weeklyvents.structs꞉> 
(throw (FormatException. "Illegal format"))
; Execution error (FormatException) at weeklyvents.structs/eval11586 (REPL:293).
; Illegal format
clj꞉weeklyvents.structs꞉> 
; Prueba 3: Comprobar si la función `parse-event` lanza una excepción de tipo `IllegalArgumentException` cuando se le proporciona una cadena con formato incorrecto
(is (thrown? IllegalArgumentException (parse-event (str "09:00:00" separador "Desayuno" separador "MONDAY"))))
; 
; FAIL in () (NO_SOURCE_FILE:298)
; expected: (thrown? IllegalArgumentException (parse-event (str "09:00:00" separador "Desayuno" separador "MONDAY")))
;   actual: nil
nil
clj꞉weeklyvents.structs꞉> 
; Prueba 3: Comprobar si la función `parse-event` lanza una excepción de tipo `IllegalArgumentException` cuando se le proporciona una cadena con formato incorrecto
(is
 (thrown? IllegalArgumentException (parse-event "09:00:00¦Desayuno¦MONDAY")))
; 
; ERROR in () (NO_SOURCE_FILE:24)
; expected: (thrown? IllegalArgumentException (parse-event "09:00:00¦Desayuno¦MONDAY"))
;   actual: com.github.alexisc183.forconsol.FormatException: null
;  at weeklyvents.structs$parse_event.invokeStatic (NO_SOURCE_FILE:24)
;     weeklyvents.structs$parse_event.invoke (NO_SOURCE_FILE:20)
;     weeklyvents.structs$eval11590.invokeStatic (NO_SOURCE_FILE:308)
;     weeklyvents.structs$eval11590.invoke (NO_SOURCE_FILE:307)
;     clojure.lang.Compiler.eval (Compiler.java:7176)
;     nrepl.middleware.interruptible_eval$evaluator$run__1443$fn__1454.invoke (interruptible_eval.clj:106)
;     nrepl.middleware.interruptible_eval$evaluator$run__1443.invoke (interruptible_eval.clj:101)
;     nrepl.middleware.session$session_exec$session_loop__1526.invoke (session.clj:230)
;     nrepl.SessionThread.run (SessionThread.java:21)
nil
clj꞉weeklyvents.structs꞉> 
(parse-event "09:00:00¦Desayuno¦MONDAY")
; Execution error (FormatException) at weeklyvents.structs/parse-event (REPL:24).
; null
clj꞉weeklyvents.structs꞉> 
(is (thrown? ArithmeticException (/ 1 0))) 
#error {
 :cause "Divide by zero"
 :via
 [{:type java.lang.ArithmeticException
   :message "Divide by zero"
   :at [clojure.lang.Numbers divide "Numbers.java" 188]}]
 :trace
 [[clojure.lang.Numbers divide "Numbers.java" 188]
  [clojure.lang.Numbers divide "Numbers.java" 3901]
  [weeklyvents.structs$eval11594 invokeStatic "NO_SOURCE_FILE" 327]
  [weeklyvents.structs$eval11594 invoke "NO_SOURCE_FILE" 327]
  [clojure.lang.Compiler eval "Compiler.java" 7176]
  [nrepl.middleware.interruptible_eval$evaluator$run__1443$fn__1454 invoke "interruptible_eval.clj" 106]
  [nrepl.middleware.interruptible_eval$evaluator$run__1443 invoke "interruptible_eval.clj" 101]
  [nrepl.middleware.session$session_exec$session_loop__1526 invoke "session.clj" 230]
  [nrepl.SessionThread run "SessionThread.java" 21]]}
clj꞉weeklyvents.structs꞉> 
(println 6)
; 6
nil
clj꞉weeklyvents.structs꞉> 
(is (thrown? ArithmeticException (/ 1 0)))
#error {
 :cause "Divide by zero"
 :via
 [{:type java.lang.ArithmeticException
   :message "Divide by zero"
   :at [clojure.lang.Numbers divide "Numbers.java" 188]}]
 :trace
 [[clojure.lang.Numbers divide "Numbers.java" 188]
  [clojure.lang.Numbers divide "Numbers.java" 3901]
  [weeklyvents.structs$eval11598 invokeStatic "NO_SOURCE_FILE" 349]
  [weeklyvents.structs$eval11598 invoke "NO_SOURCE_FILE" 349]
  [clojure.lang.Compiler eval "Compiler.java" 7176]
  [nrepl.middleware.interruptible_eval$evaluator$run__1443$fn__1454 invoke "interruptible_eval.clj" 106]
  [nrepl.middleware.interruptible_eval$evaluator$run__1443 invoke "interruptible_eval.clj" 101]
  [nrepl.middleware.session$session_exec$session_loop__1526 invoke "session.clj" 230]
  [nrepl.SessionThread run "SessionThread.java" 21]]}
clj꞉weeklyvents.structs꞉> 
(/ 1 0)
; Execution error (ArithmeticException) at weeklyvents.structs/eval11600 (REPL:367).
; Divide by zero
clj꞉weeklyvents.structs꞉> 
(is
 (thrown? FormatException (parse-event "09:00:00¦Desayuno¦MONDAY")))
#error {
 :cause nil
 :via
 [{:type com.github.alexisc183.forconsol.FormatException
   :message nil
   :at [weeklyvents.structs$parse_event invokeStatic "NO_SOURCE_FILE" 24]}]
 :trace
 [[weeklyvents.structs$parse_event invokeStatic "NO_SOURCE_FILE" 24]
  [weeklyvents.structs$parse_event invoke "NO_SOURCE_FILE" 20]
  [weeklyvents.structs$eval11602 invokeStatic "NO_SOURCE_FILE" 372]
  [weeklyvents.structs$eval11602 invoke "NO_SOURCE_FILE" 371]
  [clojure.lang.Compiler eval "Compiler.java" 7176]
  [nrepl.middleware.interruptible_eval$evaluator$run__1443$fn__1454 invoke "interruptible_eval.clj" 106]
  [nrepl.middleware.interruptible_eval$evaluator$run__1443 invoke "interruptible_eval.clj" 101]
  [nrepl.middleware.session$session_exec$session_loop__1526 invoke "session.clj" 230]
  [nrepl.SessionThread run "SessionThread.java" 21]]}
clj꞉weeklyvents.structs꞉> 
; Prueba 4: Comprobar si la función `parse-event` lanza una excepción de tipo `IllegalArgumentException` cuando se le proporciona una cadena con formato incorrecto
(is
 (thrown? IllegalArgumentException (parse-event "09:00:00¦Desayuno¦MONDAY")))
; 
; ERROR in () (NO_SOURCE_FILE:24)
; expected: (thrown? IllegalArgumentException (parse-event "09:00:00¦Desayuno¦MONDAY"))
;   actual: com.github.alexisc183.forconsol.FormatException: null
;  at weeklyvents.structs$parse_event.invokeStatic (NO_SOURCE_FILE:24)
;     weeklyvents.structs$parse_event.invoke (NO_SOURCE_FILE:20)
;     weeklyvents.structs$eval11604.invokeStatic (NO_SOURCE_FILE:392)
;     weeklyvents.structs$eval11604.invoke (NO_SOURCE_FILE:391)
;     clojure.lang.Compiler.eval (Compiler.java:7176)
;     nrepl.middleware.interruptible_eval$evaluator$run__1443$fn__1454.invoke (interruptible_eval.clj:106)
;     nrepl.middleware.interruptible_eval$evaluator$run__1443.invoke (interruptible_eval.clj:101)
;     nrepl.middleware.session$session_exec$session_loop__1526.invoke (session.clj:230)
;     nrepl.SessionThread.run (SessionThread.java:21)
nil
clj꞉weeklyvents.structs꞉> 
; Prueba 3: Comprobar si la función `parse-event` lanza una excepción de tipo `FormatException` cuando se le proporciona una cadena con formato incorrecto
(is
 (thrown? FormatException (parse-event "09:00:00¦Desayuno¦MONDAY")))
#error {
 :cause nil
 :via
 [{:type com.github.alexisc183.forconsol.FormatException
   :message nil
   :at [weeklyvents.structs$parse_event invokeStatic "NO_SOURCE_FILE" 24]}]
 :trace
 [[weeklyvents.structs$parse_event invokeStatic "NO_SOURCE_FILE" 24]
  [weeklyvents.structs$parse_event invoke "NO_SOURCE_FILE" 20]
  [weeklyvents.structs$eval11606 invokeStatic "NO_SOURCE_FILE" 410]
  [weeklyvents.structs$eval11606 invoke "NO_SOURCE_FILE" 409]
  [clojure.lang.Compiler eval "Compiler.java" 7176]
  [nrepl.middleware.interruptible_eval$evaluator$run__1443$fn__1454 invoke "interruptible_eval.clj" 106]
  [nrepl.middleware.interruptible_eval$evaluator$run__1443 invoke "interruptible_eval.clj" 101]
  [nrepl.middleware.session$session_exec$session_loop__1526 invoke "session.clj" 230]
  [nrepl.SessionThread run "SessionThread.java" 21]]}
clj꞉weeklyvents.structs꞉> 
; Prueba 4: Comprobar si la función `parse-event` lanza una excepción de tipo `IllegalArgumentException` cuando se le proporciona una cadena con formato incorrecto
(is
 (thrown? IllegalArgumentException (parse-event "09:00:00¦Desayuno¦MONDAY")))
; 
; ERROR in () (NO_SOURCE_FILE:24)
; expected: (thrown? IllegalArgumentException (parse-event "09:00:00¦Desayuno¦MONDAY"))
;   actual: com.github.alexisc183.forconsol.FormatException: null
;  at weeklyvents.structs$parse_event.invokeStatic (NO_SOURCE_FILE:24)
;     weeklyvents.structs$parse_event.invoke (NO_SOURCE_FILE:20)
;     weeklyvents.structs$eval11608.invokeStatic (NO_SOURCE_FILE:430)
;     weeklyvents.structs$eval11608.invoke (NO_SOURCE_FILE:429)
;     clojure.lang.Compiler.eval (Compiler.java:7176)
;     nrepl.middleware.interruptible_eval$evaluator$run__1443$fn__1454.invoke (interruptible_eval.clj:106)
;     nrepl.middleware.interruptible_eval$evaluator$run__1443.invoke (interruptible_eval.clj:101)
;     nrepl.middleware.session$session_exec$session_loop__1526.invoke (session.clj:230)
;     nrepl.SessionThread.run (SessionThread.java:21)
nil
clj꞉weeklyvents.structs꞉> 
; Prueba 5: Comprobar si las funciones `event-to-string` y `event-to-serialized-string` devuelven la misma cadena
(def evento (struct event (LocalTime/now) "Siesta" DayOfWeek/MONDAY))
#'weeklyvents.structs/evento
clj꞉weeklyvents.structs꞉> 
(is (= (event-to-string evento) (event-to-serialized-string evento)))
; 
; FAIL in () (NO_SOURCE_FILE:450)
; expected: (= (event-to-string evento) (event-to-serialized-string evento))
;   actual: (not (= "14:53:18.539668982 Siesta" "14:53:18.539668982SiestaMONDAY"))
false
clj꞉weeklyvents.structs꞉> 
#'weeklyvents.structs/parse-event
clj꞉weeklyvents.structs꞉> 
; Prueba de regresión 1: Comprobar si la función `parse-event` lanza una excepción de tipo `FormatException` cuando se le proporciona una cadena con el nuevo formato
(is
 (thrown? FormatException (parse-event "09:00:00¦Desayuno¦MONDAY")))
; 
; FAIL in () (NO_SOURCE_FILE:460)
; expected: (thrown? FormatException (parse-event "09:00:00¦Desayuno¦MONDAY"))
;   actual: nil
nil
clj꞉weeklyvents.structs꞉> 
; Prueba de regresión 2: Comprobar que la función `event-to-serialized-string` devuelva una cadena igual a la de la variable `s`
(def s "09:00:00¦Desayuno¦MONDAY")
#'weeklyvents.structs/s
clj꞉weeklyvents.structs꞉> 
(is (= s (event-to-serialized-string (parse-event s))))
; 
; FAIL in () (NO_SOURCE_FILE:472)
; expected: (= s (event-to-serialized-string (parse-event s)))
;   actual: (not (= "09:00:00¦Desayuno¦MONDAY" "09:00¦Desayuno¦MONDAY"))
false
clj꞉weeklyvents.structs꞉> 
; Prueba de regresión 2: Comprobar que la función `event-to-serialized-string` devuelva una cadena igual a la de la variable `s`
(def s "19:00:30¦Cena¦MONDAY")
#'weeklyvents.structs/s
clj꞉weeklyvents.structs꞉> 
(is (= s (event-to-serialized-string (parse-event s))))
true
clj꞉weeklyvents.structs꞉> 
